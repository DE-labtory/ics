---
ics: '18'
title: Relayer 알고리즘
stage: 초안
category: IBC/TAO
requires: 24, 25, 26
author: Christopher Goes <cwgoes@tendermint.com>
created: '2019-03-07'
modified: '2019-08-25'
---

## 개요

Relayer 알고리즘은 IBC의 "물리적인" 연결 계층입니다. 이 알고리즘은 IBC 프로토콜을 실행하는 두 체인 사이에 정보를 전달(중계)하는 off-chain 프로세스로, 프로토콜에서 허용하는 대로 각 체인의 상태를 살펴보고, 적절한 데이터그램을 만들며, 이를 상대 체인에서 실행합니다.

### 동기

IBC 프로토콜에서, 블록체인은 다른 체인으로 특정 정보를 보낸다는 *의도*만을 기록합니다 —  즉 블록체인은 네트워크 전송 계층에 직접 접근하지 않습니다. 물리적인 데이터그램은 TCP/IP와 같은 전송 계층에 접근하는 off-chain 인프라에 의해 수행되어야 합니다. 이 표준은 *relayer* 알고리즘의 개념을 정의하며, 알고리즘은 체인간 중계를 수행하기 위하여 체인의 상태를 질의할 수 있는 off-chain 프로세스에 의해 실행됩니다.

### 정의

*relayer*란 IBC 프로토콜을 이용하는 원장의 상태를 읽고 원장에 트랜잭션을 보내는 off-chain 프로세스입니다.

### 요구 속성

- Relayer가 비잔틴이라고 가정하면, IBC의 안전 속성인 '정확히-한번(exactly-once)'이나 '전달-또는-시간초과(deliver-or-timeout)'는 relayer 행동에 의존하면 안 됩니다.
- IBC의 패킷 전달의 liveness는 최소 하나의 올바른 live 상태의 relayer의 존재에만 의존해야 합니다.
- 전달은 권한에 관계 없이 일어나야 하며, 필요한 모든 검증은 on-chain에서 수행되어야 합니다.
- IBC 사용자와 relayer 사이 소통의 필요성은 최소화해야 합니다.
- 어플리케이션 계층에서 relayer에게 보상을 제공할 수 있어야 합니다.

## 기술 사양

### 기본 relayer 알고리즘

Relayer 알고리즘은 IBC 프로토콜로 구현된 체인 집합 `C`에서 정의됩니다. 각 relayer는 꼭 인터체인 네트워크의 모든 체인의 상태를 읽거나 데이터그램을 쓸 필요는 없습니다 (특히 허가형 또는 프라이빗 체인의 경우) — 다른 relayer는 다른 부분집합 사이를 중계할 것입니다.

`pendingDatagrams`은 두 체인에 상태에 따라서 한 체인에서 다른 체인으로 전달되는 모든 유효한 데이터그램 집합을 계산합니다. 이 함수의 하위 구성요소는 개별 ICS에 정의됩니다. Relayer는 중계하려는 블록체인이 IBC 프로토콜의 어떤 부분을 구현했는지에 대한 사전 지식을 가지고 있어야 합니다 (예. 소스 코드를 읽음).

`submitDatagram`은 체인마다 정의된 (일종의 트랜잭션을 제출하는) 절차입니다.

```typescript
function relay(C: Set<Chain>) {
  for (const chain of C)
    for (const counterparty of C)
      if (counterparty !== chain) {
        const datagrams = chain.pendingDatagrams(counterparty)
        for (const datagram of datagrams)
          counterparty.submitDatagram(datagram)
      }
}
```

### 순서 결정의 제약 사항

Relayer 프로세스에는 데이터그램을 어떤 순서로 제출할지 결정할 때 고려하는 암시적인 순서 결정의 제약 사항이 있습니다. 예를 들어, 패킷이 전달되기 전에 light client에서 특정 height에서 저장된 합의 상태와 commitment root를 완결하기 위해서 header가 제출되어야 합니다. Relay 프로세스는 무엇을 언제 전달할지를 결정하기 위하여 해당 체인의 상태를 자주 질의할 의무가 있습니다.

### Bundling

만약 대상 상태머신이 기능을 지원한다면, relayer 프로세스는 여러 데이터그램을 하나의 트랜잭션에 넣을 수 있습니다. 이는 데이터그램이 순서대로 실행하게 하고, 수수료 지불을 위한 서명 확인과 같은 오버헤드 비용을 나누어 부담하게 합니다.

### 경쟁 상태 (Race conditions)

같은 모듈과 체인 사이를 중계하는 여러 relayer는 동시에 동일한 패킷을 전달하려고 (또는 동일한 header를 제출하려고) 시도할 수도 있습니다. 만약 두 relayer가 그렇게 한다면, 첫번째 트랜잭션은 성공할 것이고, 두번째 트랜잭션은 실패할 것입니다. 이를 완화하기 위해서는, relayer 간의 또는 원본 패킷을 보내는 actor와 relayer 간 대역 외 조직이 필요합니다. 이 이상의 논의는 이 표준 문서의 범위 밖입니다.

### 장려금 및 보상 (Incentivisation)

Relay 프로세스는 트랜잭션 수수료를 지불해야 하기 때문에 충분한 잔액이 있는 중계하는 양 체인의 계정에 접근할 수 있어야만 합니다. Relayer는 이 수수료를 만회하기 위해서 어플리케이션 레벨의 방법을 사용할 수도 있습니다. 예로, 패킷 정보에 relayer 스스로를 위한 작은 양의 지불을 포함할 수 있습니다. Relayer의 수수료 지불에 대한 프로토콜은 이 ICS의 미래 버전이나 별개의 ICS에 설명할 것입니다.

몇 relayer 프로세스는 안전하게 병렬로 실행될 수도 있습니다. (병렬로 실행되는 프로세스는 인터체인의 별개의 부분집합을 처리할 것으로 기대됩니다.) 그러나 병렬로 실행되는 프로세스가 동일한 증명을 여러번 제출한다면 불필요한 수수료를 지출하게 되고, 따라서 몇 최소한의 조직화를 하는 것이 이상적일 수 있습니다. 예를 들어 특정한 패킷에 특정한 relayer를 할당하거나 보류 중(pending)인 트랜잭션의 mempool을 살펴봅니다.

## 하위 호환성

적용되지 않습니다. Relayer 프로세스는 off-chain이며, 필요에 의해 업그레이드되거나 다운그레이드 될 수 있습니다.

## 상위 호환성

적용되지 않습니다. Relayer 프로세스는 off-chain이며, 필요에 의해 업그레이드되거나 다운그레이드 될 수 있습니다.

## 구현 예제

곧 추가될 예정입니다.

## 다른 구현

곧 추가될 예정입니다.

## 역사

2019년 3월 30일 - 초안 제출
2019년 4월 15일 - 형식과 명확성을 위한 수정
2019년 4월 23일 - 코멘트에 따른 수정; 초안 병합

## 저작권

이 게시물의 모든 내용은 [Apache 2.0](https://www.apache.org/licenses/LICENSE-2.0) 라이센스에 의해 보호받습니다.
