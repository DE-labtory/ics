# 4: IBC 활용 사례들

**블록체인 간 통신 프로토콜 사양에서 사용되는 응용 프로그램 수준의 활용 사례들에 대한 설명입니다.**

**IBC 사양에 사용되는 용어에 대한 정의는 [여기를](./1_IBC_TERMINOLOGY.md) 참조 하십시오.**

**아키텍처 개요는 [여기를](./2_IBC_ARCHITECTURE.md) 참조 하십시오.**

**광범위한 프로토콜 설계 원칙에 대해서는 [여기를](./3_IBC_DESIGN_PRINCIPLES.md) 참조 하십시오.**

**디자인 패턴은 [여기를](./5_IBC_DESIGN_PATTERNS.md) 참조 하십시오.**

이 문서는 블록체인 간 통신 프로토콜(IBC)에 대한 구체적인 활용 사례들에 대한 설명과는 거리가 멀며, 프로토콜의 설계를 평가할 수 있는 일련의 관점을 제공하고, 영감을 주기 위한 의도로 작성되었습니다.

각각의 사례에 대해서 관련된 체인들의 요구사항, 상위 레벨의 패킷 처리 로직, 연관된 체인의 결합된 상태 관점에서 유지되는 응용프로그램의 속성, 비교 우위가 다른 잠재적 관련 영역들의 목록 또는 다른 응용 프로그램의 특성들을 정의합니다.

## 자산 이동

호환가능한 기본 자산 표현이 존재하는 경우, IBC를 이용하여 두 체인간에 자산을 전송할 수 있습니다.

### 대체 가능한(Fungible) 토큰

IBC는 체인들간에 대체 가능한 토큰을 전송하는데 사용할 수 있습니다.

#### 표현

비트코인에서는 `UTXO`, 이더리움에서는 `ERC20`, 코스모스 SDK에서는 `sdk.Coins`이라고 표현합니다.

#### 구현

두 개의 체인은 IBC 패킷을 전송 및 처리할 때 필요에 따라 예치, 예치 해제, 발행과 소각과 같이 의미적으로 호환되는 표현을 서로 연결하도록 선택합니다.

전체 토큰 잔액으로 시작하는 "소스 영역(source zone)"과 토큰 잔액 0으로 시작하는 "타켓 영역(target zone)"이 있거나 두 영역이 모두 0이 아닌 잔액(아마 세번째 영역(zone)에서 발행된 토큰)으로 시작될 수 있습니다. 또는 두 개의 영역의 발행량을 결합하여 이전에 별개로 존재하던 두 개의 토큰을 교환 할 수 있도록 선택할 수 있습니다.

#### 불변값

모든 연결된 표현에 걸쳐 임의의 금액의 대체 가능성(fungibility), 체인 전체에 걸쳐 일정한 (또는 인플레이션 자산의 경우 공식적인) 총 발행량 누적분 또는 토큰은 한번에 하나의 체인에서 소비 가능한 형태로만 존재합니다.

### 대체 불가능한(Non-fungible) 토큰

IBC는 체인들간에 대체 불가능한 토큰을 전송하는데 사용할 수 있습니다.

#### 표현

이더리움에서는 `ERC721`, 코스모스 SDK에서는 `sdk.NFT`이라고 표현합니다.

#### 구현

두 개의 체인은 의미적으로 호환되는 두 개의 대체 불가능한(non-fungible) 토큰의 네임스페이스를 서로 "연결(peg)"하여 IBC 패킷을 전송 및 처리할 때 필요에 따라 예치, 예치 해제, 생성과, 소멸 기능을 실행하도록 합니다.

특정 토큰으로 시작하고 토큰 관련 로직 (예 : CryptoKitties의 교배, 디지털 티켓 교환)이 포함된 시작 "소스 영역(source zone)"이 있거나 모든 관련 체인이 이해할 수있는 형식으로 관련 로직이 NFT와 함께 패키지될 수 있습니다. 

#### 불변값

대체 불가능한(non-fungible) 토큰은 특정 계정이 소유하고 있는한 한 체인에 언제라도 고유하게 존재하며, 필요하다면 관련 작업  (예 : CryptoKitties의 교배)을 수행하기 위해 언제든 "소스(source)"영역으로 다시 전송할 수 있습니다.

### 관련된 영역(zone)들

#### Vanilla payments

코스모스 허브와 같은 "vanilla payments"영역(zone)은 IBC를 통해 들어오고 나가는 대체 가능(fungible) 토큰과 대체 불가능(non-fungible) 토큰의 전송을 혀용할 수 있습니다. 사용자는 높은 보안 성 또는 높은 연결성으로 인해 이러한 영역에 자산을 유지하도록 선택할 수 있습니다.

#### Shielded payments

Zcash 블록체인 (pending [UITs](https://github.com/zcash/zcash/issues/830))과 같은 "shielded payments"영역(zone)은 IBC를 통해 들어오고 나가는 대체 가능(fungible) 토큰과 대체 불가능(non-fungible) 토큰의 전송을 혀용할 수 있습니다. 이러한 영역(zone)으로 전송된 토큰은 영지식 회로를 통해 보호되고, 보유, 전송, 거래 등이 가능합니다. 사용자가 익명을 요구하는 목적을 달성하면 IBC를 통해 다른 영역으로 다시 전송 될 수 있습니다.

#### DEX

"DEX"영역(zone)은 IBC를 통해 들어오고 나가는 대체 가능(fungible) 토큰과 대체 불가능(non-fungible) 토큰의 전송을 혀용할 수 있으며, Uniswap 또는 0x(또는 미래의 그러한 프로토콜) 스타일의 DEX 프로토콜을 통해 해당 영역에 저장된 토큰을 서로 교환할 수 있습니다.

#### De-Fi

이더리움 블록체인과 같은 "De-Fi"영역(zone)은 IBC를 통해 들어오고 나가는 대체 가능(fungible) 토큰과 대체 불가능(non-fungible) 토큰의 전송을 혀용할 수 있으며, 해당 영역(zone)에 저장된 토큰이 담보 대출, 유동성 풀과 같이 다양한 De-Fi 상품들과 상호 작용할 수 있습니다.

## 멀티체인 컨트랙트

여러 체인들에 컨트랙트들이 있어 로직이 분리되어 있는 경우, IBC를 이용하여 컨트랙트들간에 메세지 및 데이터를 전달할 수 있습니다.

### 크로스체인 컨트랙트 호출

IBC를 사용하면 별도의 스마트 컨트랙트 플랫폼 체인들간에 calldata와 return data를 포함한 임의의 컨트랙트-컨트랙트 호출을 실행할 수 있습니다. 

#### 표현

컨트랙트: 이더리움에서는 `EVM`, `WASM` (그 외 다양함), Tezos에서는 `Michelson`, Agoric에서는 `Jessie`라고 표현합니다..

Calldata: 이더리움에서는 `ABI`라고 하며, RLP, Protobuf 또는 JSON과 같은 일반 직렬화 형식으로 표현됩니다.

#### 구현

한 영역(zone)에서 다른 영역(zone)에 존재하는 컨트랙트를 호출하려는 컨트랙트는 IBC패킷을 통해 대상 컨트랙트의 calldata 및 주소를 직렬화해야 하며, IBC 커넥션을 통해 대상 체인의 IBC 핸들러로 중계될 수 있습니다. 지정된 컨트랙트를 호출, 관련 로직 실행 및 호출의 결과를 반환하는 것(해당하는 경우)은 두번째 IBC 패킷을 통해 다시 호출했던 컨트랙트로 전송합니다. 이때 이 동작은 비동기적으로 처리해야 합니다.

체인들을 구현하면  Go 또는 Haskell과 같은 언어의 다중 프로세스 동시성 프로그래밍의 채널과 매우 유사한 송신 엔드(send end), 수신 엔드(receive end), 구성 가능한 버퍼 크기 등을 컨트랙트 개발자에게 "채널" 개체로 제공할 수 있습니다.

#### 불변값

컨트랙트에 따라 다릅니다.

### 크로스체인 수수료 지불

#### 표현

위의 **대체 가능한(Fungible) 토큰**에서의 표현과 동일합니다.

#### 구현

한 체인에서 자산을 가지고 있는 계정은 두번째 체인의 검증자에 의해 제어되고 있는 첫번째 체인의 다른 계정에 토큰을 전송하고 첫번째 체인에서 두번째 체인으로 토큰을 전송했다는 증거를 포함함으로써  다른 체인의 수수료 지불에 사용될 수 있습니다.

해당 자산은 수수료 지불을 위해 IBC 커넥션을 통해 첫번째 체인에서 두번째 체인으로 정기적으로 다시 보낼 수 있습니다.

#### 불변값

두 체인들 중 한쪽에서만 수수료가 지불됩니다.

### 인터체인 담보물

> 담보물이란 인터체인 프로토콜에서 검증자가 되기 위해 제출하는 토큰을 의미

한 체인에서 지정된 검증자 그룹의 일부는 다른 체인의 유효성을 검사하도록 선택할 수 있고, IBC 커넥션을 통해 제출된 해당 체인에서 커밋에 결함이 있을 경우 책임을 져야하며, 두번째 체인은 동일한 IBC 커넥션을 통해 첫번째 체인에 검증자 업데이트 로직을 위임할 수 있습니다.

#### 표현

ABCI에서는 `Evidence` 와 `ValidatorUpdate`라고 표현합니다.

#### 구현

1차(담보) 체인의 검증자 그룹의 일부에 대한 `ValidatorUpdate`는 IBC 패킷에서 담보 체인으로 중계되며, 이를 사용하여 자체 검증자 그룹을 설정합니다. 

어떤 소유의 `Evidence`는 담보 체인에서 기본 체인으로 다시 중계되어 위변조를 한 검증자에 대해서 담보물 몰수(slashing)를 진행할 수 있습니다.

#### 불변값

검증에 실수를 저지른 검증자들은 하나 이상의 체인에서 몰수(slashing)가 가능하며, 담보 체인의 검증자 그룹은 기본(담보) 체인의 검증자들 그룹에 바인딩될 수 있습니다.

## 샤딩

IBC를 사용하면 블록체인간에 스마트 계약 및 데이터를 상호 이해 가능한 가상 머신 및 데이터 형식으로 마이그레이션 할 수 있습니다.

### 코드 마이그레이션

#### 표현

위의 **크로스체인 컨트랙트 호출**에서의 표현과 동일하며, 관련된 모든 코드가 직렬화 가능하고 관련 체인에 의해 상호 이해 가능 (실행 가능)해야한다는 추가 요구 사항이 있습니다.

#### 구현

참여하는 체인은 컨트랙트들을 마이그레이션하며, 알려진 밸런싱 알고리즘("샤딩")에 따라 체인들 사이에서 모두 실행할 수 있습니다. 또한 자주 상호 작용하는 컨트랙트들에 대해서 로드를 균등하게 하거나 효율적인 지역성을 달성하도록 설계되었습니다.

체인을 자주 전환하는 컨트랙트들 사이에 크로스체인 컨트랙트 호출을 올바르게 라우팅하려면 코어 IBC 위에 라우팅 시스템이 필요합니다.

#### 불변값

어떤 종류의 라우팅 시스템에 의해 코드의 의미(semantics)와 네임스페이스가 보존됩니다.

### 데이터 마이그레이션

IBC를 사용하면 스토리지 비용을 접근 비용으로 교환할 수 있는 임의의 깊이의 멀티체인 "캐시"시스템을 구현하는데 사용할 수 있습니다.

#### 표현

Amino, RLP, Protobuf, JSON과 같은 일반 직렬화 형식으로 표현합니다.

#### 구현

임의의 깊이의 IBC 커넥션(계산에 최적화된 첫번째 체인과 더 저렴한 스토리지에 최적화된 두번째 체인을 이용하여 연결)으로 연결된 체인들의 링크드 리스트는 어떤 체인의 일정 기간동안 사용되지 않은 데이터를 리스트의 다음 체인으로 마이그레이션하는 계층적인 캐시를 구현할 수 있습니다. 컨트랙트 호출 또는 스토리지 접근을 위해 데이터가 필요한데 찾는 데이터가 해당 체인에 저장되지 않은 경우, IBC 패킷을 통해 해당 체인으로 다시 중계되어야합니다(일정 기간동안 다시 캐시할 수 있음).

#### 불변값

필요한 경우 IBC hop의 알려진 범위로 기본 (계산) 체인에서 모든 데이터에 액세스 할 수 있습니다.
